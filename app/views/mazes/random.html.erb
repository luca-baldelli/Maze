<div id="maze"></div>
<script>
    var Maze = {
        random: function () {
            return m.request({method: "GET", url: "random.json"});
        }
    };
    var PathFinder = {
        isVisited: function (cell, maze) {
            if (cell[0] < 0 || cell[0] >= maze.length || cell[1] < 0 || cell[1] >= maze.length) {
                return true;
            }
//            for (var i = 0; i < path.length; i++) {
//                if (cell[0] == path[i][0] && cell[1] == path[i][1]) {
//                    return true;
//                }
//            }
            return maze[cell[0]][cell[1]].visited === true;
        },
        neighbour: function (currentRow, currentColumn, direction) {
            var row = currentRow;
            var column = currentColumn;
            if (direction === 'up') {
                column -= 1;
            } else if (direction === 'down') {
                column += 1;
            } else if (direction === 'left') {
                row -= 1;
            } else if (direction === 'right') {
                row += 1;
            }

            return [row, column];
        },
        unexploredDirections: function (directions, currentRow, currentColumn, maze) {
            var unexploredDirections = [];

            for (var i = 0; i < directions.length; i++) {
                if (!PathFinder.isVisited(PathFinder.neighbour(currentRow, currentColumn, directions[i]), maze)) {
                    unexploredDirections.push(directions[i]);
                }
            }

            return unexploredDirections;
        },
        randomDirection: function (availableDirections, currentRow, currentColumn, maze) {
            var unexploredDirections = PathFinder.unexploredDirections(availableDirections, currentRow, currentColumn, maze);
            return unexploredDirections[Math.floor(Math.random() * unexploredDirections.length)];
        },
        backToFork: function (path, maze) {
            var i;
            for (i = path.length - 1; i >= 0; i--) {
                if (PathFinder.unexploredDirections(['up', 'down', 'left', 'right'], path[i][0], path[i][1], maze).length > 0) {
                    break;
                } else {
                    maze[path[i][0]][path[i][1]].solution = false;
                }
            }
            path.slice(0, i + 1);
            return [path[i][0], path[i][1]];
        },
        findPath: function (maze) {
            var currentRow = 0;
            var currentColumn = 0;
            var path = [[currentRow, currentColumn]];
            maze[currentRow][currentColumn].visited = true;
            maze[currentRow][currentColumn].solution = true;
            var deadEnd = false;

//            while (!deadEnd) {
            while (!(currentRow === maze.length - 1 && currentColumn === maze.length - 1)) {
                var availableDirections = maze[currentRow][currentColumn].open;
                var randomDirection = PathFinder.randomDirection(availableDirections, currentRow, currentColumn, maze);
                if (randomDirection === 'up') {
                    currentColumn -= 1;
                    path.push([currentRow, currentColumn]);
                    maze[currentRow][currentColumn].visited = true;
                    maze[currentRow][currentColumn].solution = true;
                } else if (randomDirection === 'down') {
                    currentColumn += 1;
                    path.push([currentRow, currentColumn]);
                    maze[currentRow][currentColumn].visited = true;
                    maze[currentRow][currentColumn].solution = true;
                } else if (randomDirection === 'left') {
                    currentRow -= 1;
                    path.push([currentRow, currentColumn]);
                    maze[currentRow][currentColumn].visited = true;
                    maze[currentRow][currentColumn].solution = true;
                } else if (randomDirection === 'right') {
                    currentRow += 1;
                    path.push([currentRow, currentColumn]);
                    maze[currentRow][currentColumn].visited = true;
                    maze[currentRow][currentColumn].solution = true;
                } else {
                    deadEnd = true;
                    var fork = PathFinder.backToFork(path, maze);
                    currentRow = fork[0];
                    currentColumn = fork[1];
                }

            }
//            for (var i = 0; i < maze.length; i++) {
//                for (var j = 0; j < maze[i].length; j++) {
//                    maze[i][j].solution = true;
//                }
//            }
        }
    };

    var MazeApp = {
        controller: function () {
            var maze = Maze.random();
            return {
                maze: maze,
                findPath: function () {

                }
            }
        },

        //view
        view: function (ctrl) {
            var maze = ctrl.maze();
            PathFinder.findPath(maze);

            return m("div.maze", [
                ctrl.maze().map(function (column) {
                    return m(".column", [
                        column.map(function (cell) {
                            var wallClasses = cell.wall.join(' ');
                            var solutionClass = cell.solution ? 'solution' : '';
                            var startClass = cell.start ? 'start' : '';
                            var endClass = cell.end ? 'end' : '';
                            return m("div", {
                                class: 'wall ' +
                                wallClasses + ' ' +
                                solutionClass + ' ' +
                                startClass + ' ' +
                                endClass
                            });
                        })
                    ]);
                })
            ]);
        }
    };


    //initialize
    m.mount(document.getElementById("maze"), MazeApp);
</script>